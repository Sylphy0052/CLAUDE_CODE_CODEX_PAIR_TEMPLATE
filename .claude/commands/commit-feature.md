---
description: |
  [Gitコミット] 現在の変更を分析し、日本語のConventional Commitメッセージを自動生成してコミットします。
argument_hint: "[コミットする内容の要約 (任意)]"
notes: |
  バージョン: 1.0
  Git担当: @git-committer
---
# 対話型Gitコミットコマンド (ccommit)

このコマンドは、現在の作業ディレクトリの変更点を分析し、**日本語Conventional Commits規約**に基づいたコミットメッセージを自動生成して、安全にコミットを実行します。

## Conventional Commitsとは？

コミットメッセージを `種類(スコープ): 要約` という形式で記述する規約です。

- **種類**: `feat`(機能), `fix`(修正), `docs`(文書), `refactor`(リファクタ), `test`(テスト), `chore`(その他)など
- **スコープ**: 変更が影響する範囲 (例: `api`, `db`, `ui` など)
- **要約**: 変更内容を簡潔に記述

この規約により、Gitの履歴が非常に分かりやすくなります。

## 使用例

```bash
# 現在のタスクの内容を基に、自動でコミット内容を判断

/ccommit

# コミット内容を引数で具体的に指示

/ccommit "ユーザー認証機能のバグを修正"
```

---

## 実行フロー

### ステップ1: コミット対象の概要を把握

- **もし、引数が指定されている場合:**
  その引数をコミット対象の概要として使用します。
- **もし、引数が指定されていない場合:**
  `@state-manager` を呼び出し、現在のタスク（`current_task`）の情報を取得し、それを概要として使用します。

### ステップ2: Gitの専門家によるコミット準備 (by @git-committer)

**進捗報告:**
「Gitの変更点を分析し、最適なコミットメッセージを生成します...」

`@git-committer` エージェントを呼び出し、現在の変更点（`git diff`）とステップ1で得た概要を伝えて、コミット準備をさせます。

`@git-committer` は内部で以下の思考プロセスを実行します。

1. `git diff` を分析し、変更の意図を理解する。
2. 変更内容に最も適した **種類** (`feat`, `fix`など) を判断する。
3. 変更が影響している**スコープ**（ファイル名や機能名）を特定する。
4. これらを基に、**日本語のConventional Commitメッセージ** を生成する。
5. コミットに含めるべきファイルを `git add` する。

`@git-committer` は、最終的に「ステージングしたファイルリスト」と「生成したコミットメッセージ」を報告します。

### ステップ3: ユーザーによる最終確認

`@git-committer` から受け取った情報をユーザーに提示し、最終確認を求めます。

**確認プロンプト例:**

```bash
以下の内容でコミットを実行します。よろしいですか？ [Y/N]

**ステージングされたファイル:**

- src/main.py
- tests/test_main.py

**生成されたコミットメッセージ:**
fix(api): ユーザー取得時のデータ欠損バグを修正

レスポンスボディに'email'が含まれていなかった問題を解決。
```

### ステップ4: コミットの実行または中止

- **もし、ユーザーが 'Y' を入力した場合:**
  `git commit` を実行し、「コミットが正常に完了しました。」と報告します。
- **もし、ユーザーが 'N' を入力した場合:**
  `git reset` を実行してステージングを解除し、「操作はキャンセルされました。ステージングされたファイルは元に戻りました。」と報告します。
