---
description: "[実装ギャップ分析] 要件と実装のギャップを分析"
allowed-tools: Bash, Glob, Grep, Read, Write, Edit
argument-hint: "<feature-name>"
---

# 実装ギャップ分析

機能名: **$1** の要件と既存コードベースの実装ギャップを分析します。

## コンテキスト検証

### Steeringコンテキスト

- アーキテクチャ文脈: `.claude/steering/structure.md`
- 技術的制約: `.claude/steering/tech.md`
- プロダクト文脈: `.claude/steering/product.md`
- カスタムSteering: `.claude/steering/`内のすべてのカスタムSteeringファイル

### 既存仕様コンテキスト

以下のファイルを確認・読み込みます：

- 現在の仕様ディレクトリ: `.claude/specs/$1/`
- 要件定義書: `.claude/specs/$1/requirements.md`
- 仕様メタデータ: `.claude/specs/$1/spec.json`
- 設計書: `.claude/specs/$1/design.md`（存在する場合）

## タスク: 実装ギャップ分析

### 前提条件

- 要件定義書が存在すること: `.claude/specs/$1/requirements.md`
- 存在しない場合は停止し、メッセージを表示: "`/spec-requirements $1`を先に実行して要件定義を生成してください"

### 分析プロセス

#### 1. 現状調査

**既存コードベース分析**:
- 機能ドメインに関連するファイルとモジュールを特定
- 現在のアーキテクチャパターン、規約、技術スタック使用状況をマッピング
- 既存のサービス、ユーティリティ、再利用可能なコンポーネントを文書化
- 現在のデータモデル、API、統合パターンを理解

**コード構造評価**:
- ファイル構成、命名規則、アーキテクチャレイヤーを文書化
- import/exportパターンとモジュール依存構造を抽出
- 既存のテストパターン（ファイル配置、フレームワーク、モックアプローチ）を特定
- 現在使用されているAPIクライアント、データベース、認証実装アプローチをマッピング
- 確立されたコーディング基準と開発プラクティスを記録

#### 2. 要件実現可能性分析

**技術要件抽出**:
- requirements.mdからEARS形式要件を解析
- 各要件に必要な技術コンポーネントを特定
- 非機能要件（セキュリティ、パフォーマンスなど）を抽出
- ビジネスロジックの複雑さと統合ポイントをマッピング

**ギャップ特定**:
- 要件に対する不足している技術的能力
- 未知の技術や外部依存関係
- 既存システムとの統合における潜在的な課題
- 研究またはPOC（概念実証）作業が必要な領域

#### 3. 実装アプローチオプション

**複数戦略評価**:

- **オプションA**: 既存コンポーネント・ファイルの拡張
  - 拡張する既存ファイル・モジュール
  - 現在のパターンとの互換性
  - コードの複雑さと保守性への影響

- **オプションB**: 新規コンポーネントの作成（正当化された場合）
  - 新しいファイル作成の明確な根拠
  - 既存システムとの統合ポイント
  - 責任境界とインターフェース

- **オプションC**: ハイブリッドアプローチ
  - 拡張と新規作成の組み合わせ
  - 段階的実装戦略
  - リスク軽減アプローチ

#### 4. 技術調査要件

**外部依存関係分析**（該当する場合）:
- 現在使用されていない必要なライブラリ、API、サービス
- 既存の依存関係とのバージョン互換性
- 認証、設定、セットアップ要件
- レート制限、使用制約、コスト影響

**知識ギャップ評価**:
- チームに馴染みのない技術
- 研究が必要な複雑な統合パターン
- 調査が必要なパフォーマンスまたはセキュリティの考慮事項
- ベストプラクティス研究要件

#### 5. 実装複雑度評価

**工数見積もり**:
- **小（S）**: 1〜3日、主に既存パターンを使用
- **中（M）**: 3〜7日、一部新しいパターンまたは統合
- **大（L）**: 1〜2週間、重要な新機能
- **特大（XL）**: 2週間以上、複雑なアーキテクチャ変更

**リスク要因**:
- 高: 未知の技術、複雑な統合、アーキテクチャ変更
- 中: 新しいパターン、外部依存関係、パフォーマンス要件
- 低: 既存パターンの拡張、十分に理解された技術

### 出力フォーマット

spec.jsonで指定された言語（`.claude/specs/$1/spec.json`の"language"フィールドを確認）で分析を生成します：

#### 分析サマリー

- 機能スコープと複雑さの概要
- 特定された主要な技術的課題
- 全体的な実装アプローチの推奨

#### 既存コードベースの洞察

- 関連する既存コンポーネントとその現在の責任
- 従うべき確立されたパターンと規約
- 利用可能な再利用可能なユーティリティとサービス

#### 実装戦略オプション

各実行可能なアプローチについて：

- **アプローチ**: [拡張/新規/ハイブリッド]
- **根拠**: このアプローチが理にかなう理由
- **トレードオフ**: このアプローチの長所と短所
- **複雑度**: [S/M/L/XL] と理由

#### 技術調査ニーズ

- 調査が必要な外部依存関係
- 研究が必要な未知の技術
- POCが必要な統合パターン
- 調査すべきパフォーマンスまたはセキュリティの考慮事項

#### 設計フェーズへの推奨事項

- 根拠を持つ推奨実装アプローチ
- 行う必要がある主要なアーキテクチャ決定
- 設計中にさらなる調査が必要な領域
- 設計フェーズで対処すべき潜在的なリスク

## 実行手順

1. **spec.jsonで言語を確認** - メタデータで指定された言語を使用
2. **前提条件検証** - 要件が生成済みであることを確認
3. **徹底的な調査** - 既存コードベースを包括的に分析
4. **複数オプション** - 実行可能な実装アプローチを提示
5. **情報重視** - 最終決定ではなく分析を提供
6. **調査特定** - 調査が必要な領域をフラグ化
7. **設計準備** - 設計フェーズを成功に導く

**重要**: これは分析フェーズです。最終的な実装決定ではなく、情報とオプションを提供します。設計フェーズでこの分析に基づいて戦略的選択を行います。

---

## 次のフェーズ: 設計生成または実装

分析後、次のステップを選択します：

**設計書がまだない場合**:
`/spec-design $1`を実行して技術設計書を作成

**設計書が既にある場合**:
`/flow-init $1`を実行して実装を開始

## 使用例

```bash
# 実装ギャップ分析
/validate-gap user-authentication

# 分析後、設計がない場合
/spec-design user-authentication

# または、設計が既にある場合
/flow-init user-authentication
```

## 実装メモ

- このコマンドは実装前または実装中に使用できます
- 実装前: 設計の前提条件を検証
- 実装中: 実装漏れや改善点を発見
- 定期的に実行してギャップを監視することを推奨
