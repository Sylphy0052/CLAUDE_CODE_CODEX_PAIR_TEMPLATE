# 安全な自動リファクタリングコマンド (refactor)

## 概要

このコマンドは、`@refactorer` エージェントを呼び出して、指定されたコードを**自動的にリファクタリング**します。  
既存のテストがすべて成功していることを確認し、安全が保証された場合のみコードを変更します。  
ユーザーの確認なしで変更が適用されます。

---

## 使用例

```bash

# Claudeを使って可読性を改善

/refactor src/utils.py "calculate_price関数の可読性を向上させて"

# Codexを使ってパフォーマンスを改善

/refactor src/core.py "process_data関数のパフォーマンスを改善して" --codex
```

---

## 実行フロー

### ステップ1: 引数の解析

コマンド入力から以下を解析します:

- 対象ファイルパス  
- リファクタリング目的（自然言語で指定）  
- `--codex` オプションの有無  

これにより、使用するエージェントと実行モードを決定します。

---

### ステップ2: 安全な自動リファクタリングの実行

**進捗報告:**  
「自動リファクタリングを開始します。まず、現在のテストがすべて成功することを確認します...」

1. **テストの安全性確認**  
   - Bash で `pytest` を実行し、現行コードがすべてのテストを通過していることを確認します。  
   - 失敗している場合はリファクタリングを中止し、エラーメッセージを報告します。

2. **リファクタリング実行 (エージェント別)**  

   - **Claudeモード (デフォルト):**  
     `@refactorer` エージェントを呼び出して、Claudeベースの自動リファクタリングを実行します。  
     内部では`@code-reviewer`を利用し、可読性・設計原則・命名改善を自動適用します。

   - **Codexモード (`--codex` オプション付き):**  
     Bash 経由で `codex` CLI を呼び出し、指定目的をもとにコードをリファクタリングします。  
     Codexの出力結果を対象ファイルに反映させます。

     具体的な内部動作:
     1. Bashで以下を実行  

        ```bash
        codex "refactor ${対象ファイル} : ${リファクタリング目的}"
        ```

     2. Codexの出力を受け取り、ファイル内容として書き込みます。
     3. 再度 Bash で `pytest` を実行し、テスト成功を確認します。
     4. 成功した場合は変更を確定し、差分(diff)を生成して報告します。  
        失敗した場合は変更を破棄し、エラー内容を報告します。

---

### ステップ3: 結果の報告

- **成功時:**  
  「リファクタリングに成功したため、変更を自動的に適用しました。」  
  と報告し、変更差分を提示します。

- **失敗時:**  
  「リファクタリング案がテストを破壊したため、変更を元に戻しました。」  
  というエラー報告を表示します。

---

## 内部動作まとめ

| ステップ | 処理内容 | 実行手段 |
|-----------|-----------|-----------|
| 1 | 引数解析 (`path`, `目的`, `--codex`) | 内部パーサ |
| 2 | テストの成功確認 | Bash: `pytest` |
| 3 | リファクタリング実行 | Claude: `@refactorer` / Codex: Bash: `codex` |
| 4 | 結果検証と反映 | Bash: `pytest` + Write |
| 5 | 差分とログ出力 | 自動生成 |

---

## 注意事項

- `--codex` オプションを付与すると、Claude ではなく **Codex CLI** による自動変換が行われます。  
- Codexが生成したコードが不正確な場合は、テスト結果に基づき自動ロールバックされます。  
- このコマンドは**ユーザー確認なしで直接変更を適用**します。

---

## 推奨使用タイミング

- 小規模な関数・モジュール単位での構造改善  
- 命名規則の統一、ループの最適化、パフォーマンス改善  
- 複雑な関数の分割・リファクタリングの自動化
